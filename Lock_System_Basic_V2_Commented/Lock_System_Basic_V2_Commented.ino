/*
 * Arduino Time-based One Time Passcode(TOTP) & Fingerprint Lock/Safe
 * 
 * This code is for an arduino Mega chip for the Computer Engineering summative.
 * It features a keypad for data entry as well as Serial communication to a networking chip and a fingerprint scanner.
 * Once the user sets a 10 digit passcode, they will enter a secret key into their google authenticator app (the code will be given during lock setup).
 * Their fingerprint will then be registered and will be used along with the TOTP and passcode to unlock their safe.
 * 
 * Refer to the NodeMCU chip for network setup instructions.
 * 
 * created Jan 22, 2020
 * by Benjamin Liu TEJ3M
 */


/*
 * Required libraries are called up and pin 'Act' is defined.
 * Array 'monthDays' is declared for the automated date setting function of the software RTC and specifies the number of days in a month.
 * Leap years are accounted for by the library itself.
 */
#include <Keypad.h>
#include <swRTC.h>
#include <sha1.h>
#include <TOTP.h>
#include "Base32_Encode.h"
#include <Adafruit_Fingerprint.h>

#define fingerSerial Serial1

const int Act = 43;

int monthDays[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

/*
 * Pins for Serial communication to Fingerprint Scanner:
 * White to pin 18 TX1(in)
 * Green to pin 19 RX1(out)
 * 
 * The fingerprint sensor is also defined here
*/

Adafruit_Fingerprint finSensor = Adafruit_Fingerprint(&fingerSerial);

/*
 * Specifies where the fingerprint should be stored.
 * In this case, always the first memory block as there should only be one fingerprint that cna open the lock.
 */
uint8_t finID = 1;

/*
 * The software RTC is started and the TOTP is defined using the user inputted passcode.
 */

swRTC rtc;

TOTP totp = TOTP(((uint8_t*)Passcode), 10);

/*
 * checks if the setup process has been completed
 */

bool hasBeenSetup = false;

/*
 * This section of code sets up the keypad and the array where entered data is stored.
 */

const int rowCount = 5;
const int columnCount = 4;

char closed[1];

char keyBinds [rowCount][columnCount] = {
  {'1', '4', '7', '#'},
  {'2', '5', '8', '0'},
  {'3', '6', '9', '*'},
  {'A', 'B', 'C', 'D'}
};

byte rowPins[rowCount] = {25, 24, 23, 22}; //TRY TO SWITCH THESE INTO ANALOG FOR HIGH/LOW SENSITIVITY
byte columnPins[columnCount] = {29, 28, 27, 26};
Keypad lockKeypad = Keypad(makeKeymap(keyBinds), rowPins, columnPins, rowCount, columnCount);

char keyEntered[10];

/*
 * Stores the TOTP generated by the system and the TOTP typed in by the user.
 */
 
char* twoFACode;
char totpEntered[6];

//int totpEntered_indx;

/*
 * Where a new password is stored after being trasmitted from your phone to the NodMCU chip and then to the Mega.
 */

char recStr[10] = "";

/*
 * Checks if the password has been remotely changed.
 */

bool hasBeenChanged = false;

/*
 * Begins the serial communication and serial communication on ports 2 for communicating with the NodeMCU chip
 */

void setup() {
  // put your setup code here, to run once:
  Serial.begin(9600); // FOR DEGBUG PURPOSES ONLY
  Serial2.begin(9600);
  pinMode(Act, OUTPUT);

  timeSet();
}

/*
 * Used to automatically configure the time for setting up the software RTC.
 * 
 * The time and date is fetched from the system and stored in a char array before getting converted to a String and then to an integer.
 * for the month, the first three chars is compared to a list to check which month it coorespnds to as an integer.
 * 
 * Since GMT is 5 hours ahead of us, this function also takes into account that and will increment days, months and even years if needed.
 * Then software RTC is then started and the arduino proceeds to the first actual section for user input.
 */

void timeSet() {
  int actualMonth;
  char compile_date[] = __DATE__ " " __TIME__;
  Serial.println(compile_date);

  char compile_year[3];
  compile_year[0] = compile_date[7];
  compile_year[1] = compile_date[8];
  compile_year[2] = compile_date[9];
  compile_year[3] = compile_date[10];
  String midYear = compile_year;
  int actualYear = midYear.toInt();

  char compile_month[3];
  compile_month[0] = compile_date[0];
  compile_month[1] = compile_date[1];
  compile_month[2] = compile_date[2];
  String midMonth = compile_month;
  if (midMonth == "Jan") {
    actualMonth = 1;
  } else if (midMonth ==  "Feb") {
    actualMonth = 2;
  } else if (midMonth == "Mar") {
    actualMonth = 3;
  } else if (midMonth == "Apr") {
    actualMonth = 4;
  } else if (midMonth == "May") {
    actualMonth = 5;
  } else if (midMonth == "Jun") {
    actualMonth = 6;
  } else if (midMonth == "Jul") {
    actualMonth = 7;
  } else if (midMonth == "Aug") {
    actualMonth = 8;
  } else if (midMonth == "Sep") {
    actualMonth = 9;
  } else if (midMonth == "Oct") {
    actualMonth = 10;
  } else if (midMonth == "Nov") {
    actualMonth = 11;
  } else if (midMonth == "Dec") {
    actualMonth = 12;
  } else {
    actualMonth = 1;
  }
  int thisMonth = monthDays[actualMonth];

  char compile_day[2];
  compile_day[0] = compile_date[4];
  compile_day[1] = compile_date[5];
  String midDay = compile_day;
  int actualDay = midDay.substring(0, 2).toInt();
  //Serial.print("Day: ");
  //Serial.println(actualDay);

  if (thisMonth == 30) {
    if (actualDay > 30) {
      actualDay = 1;
      actualMonth = actualMonth + 1;
    }
  } else {
    if (actualDay > 31) {
      actualDay = 1;
      actualMonth = actualMonth + 1;
    }
    if (actualMonth > 12) {
      actualYear = actualYear + 1;
      actualMonth = 1;
    }
  }
  //Serial.print("Year: ");
  //Serial.println(actualYear);
  //Serial.print("Month: ");
  //Serial.println(actualMonth);

  char compile_hour[1];
  compile_hour[0] = compile_date[12];
  compile_hour[1] = compile_date[13];
  String midHour = compile_hour;
  int actualHour = midHour.toInt() + 5;
  if (actualHour >= 24) {
    actualHour = actualHour - 24;
    actualDay = actualDay + 1;
  }
  //Serial.print("Hour: ");
  //Serial.println(actualHour);

  char compile_minute[2];
  compile_minute[0] = compile_date[15];
  compile_minute[1] = compile_date[16];
  String midMin = compile_minute;
  int actualMinute = midMin.substring(0, 2).toInt();
  //Serial.print("Minute: ");
  //Serial.println(actualMinute);

  char compile_seconds[2];
  compile_seconds[0] = compile_date[18];
  compile_seconds[1] = compile_date[19];
  String midSecs = compile_seconds;
  int actualSeconds = midSecs.substring(0, 2).toInt();
  //Serial.print("Seconds: ");
  //Serial.println(actualSeconds);

  rtc.stopRTC();
  rtc.setDate(actualDay, actualMonth, actualYear);
  rtc.setTime(actualHour, actualMinute, actualSeconds);
  rtc.startRTC();

  Serial.println("Real Time Clock has started...");
  takePass();
}

/*
 * This section of code takes the iput from the user and also checks if anything has been sent over from the NodeMCU chip.
 * It is only used when the Mega is running first boot and will not be used after setup unless the password is changed.
 */

void takePass() {
  if (hasBeenChanged == false) {
    Serial.println("Please Input a 10 Digit Passcode: ");
    for (int i = 0; i < 10; i++) {
      while ((Passcode[i] = lockKeypad.getKey()) == NO_KEY) {
        delay(1);
        int remLock = changePassword();
        if (remLock == 1) {
          while (remLock != 0) {
            changePassword();
          }
        }
      }
      while (lockKeypad.getKey() != NO_KEY) {
        delay(1);
      }
      Serial.print('*');
    }
    Serial.println(" ");
    Serial.print("Inputed Passcode: ");
    Serial.println(Passcode);
    textBin();
  } else if (hasBeenChanged == true) {
    hasBeenChanged = false;
    textBin();
  }
}

/*
 * This ssection of code converts the inputted password into binary and splits it into bytes.
 * If a section is shorter than 8 bits, it will be padded accordingly.
 * 
 * Then, the bytes are concatenated and are split into 'chunks', also known as 5 bits of data.
 */

void textBin() {
  for (int i = 0; i < 10; i++) {
    int ascInt = Passcode[i];
    itoa(ascInt, thisBin, 2);
    int binWritten = Serial.write(thisBin);
    Serial.print(" ");
    Serial.print(" | ");

    if (i == 0) {
      if (binWritten == 6) {
        strcpy(whyBinned, "00");
      }
      else if (binWritten == 7) {
        strcpy(whyBinned, "0");
      }
      strcat(whyBinned, thisBin);
    }
    else if (i > 0) {
      if (binWritten == 6) {
        strcat(whyBinned, "00");
      }
      else if (binWritten == 7) {
        strcat(whyBinned, "0");
      }
      strcat(whyBinned, thisBin);
    }
  }

  maybeBinned = whyBinned;

  int n = 0;

  for (int i = 0; i < 16; i++) {
    pointNumBins = maybeBinned.substring(n, n + 5);
    pointNumBins.toCharArray(bins[i], 6);

    n = n + 5;
  }

  binBase();
}

/*
 * This section, as you can see, is hard coded.
 * 
 * It compares the data in the chunks to the RFC4648 alphabet and gives a letter or number.
 * This is the Base32 conversion of the password inputted by the user and will be inputted in Google Authenticator as the Secret Key.
 */

void binBase() {
  /*
     CONVERT BINARY TO INT AND THEN USE SWITCH CASE
  */
  strcpy(secretCode, "#"); //GETS RID OF FIRST BIT, MAKE SURE TO REMOVE WHEN PRINTING
  for (int i = 0; i < 16; i++) {
    String pointBins = bins[i];

    if (pointBins == "00000") {
      strcat(secretCode, "A");
    }
    else if (pointBins == "00001") {
      strcat(secretCode, "B");
    }
    else if (pointBins == "00010") {
      strcat(secretCode, "C");
    }
    else if (pointBins == "00011") {
      strcat(secretCode, "D");
    }
    else if (pointBins == "00100") {
      strcat(secretCode, "E");
    }
    else if (pointBins == "00101") {
      strcat(secretCode, "F");
    }
    else if (pointBins == "00110") {
      strcat(secretCode, "G");
    }
    else if (pointBins == "00111") {
      strcat(secretCode, "H");
    }
    else if (pointBins == "01000") {
      strcat(secretCode, "I");
    }
    else if (pointBins == "01001") {
      strcat(secretCode, "J");
    }
    else if (pointBins == "01010") {
      strcat(secretCode, "K");
    }
    else if (pointBins == "01011") {
      strcat(secretCode, "L");
    }
    else if (pointBins == "01100") {
      strcat(secretCode, "M");
    }
    else if (pointBins == "01101") {
      strcat(secretCode, "N");
    }
    else if (pointBins == "01110") {
      strcat(secretCode, "O");
    }
    else if (pointBins == "01111") {
      strcat(secretCode, "P");
    }
    else if (pointBins == "10000") {
      strcat(secretCode, "Q");
    }
    else if (pointBins == "10001") {
      strcat(secretCode, "R");
    }
    else if (pointBins == "10010") {
      strcat(secretCode, "S");
    }
    else if (pointBins == "10011") {
      strcat(secretCode, "T");
    }
    else if (pointBins == "10100") {
      strcat(secretCode, "U");
    }
    else if (pointBins == "10101") {
      strcat(secretCode, "V");
    }
    else if (pointBins == "10110") {
      strcat(secretCode, "W");
    }
    else if (pointBins == "10111") {
      strcat(secretCode, "X");
    }
    else if (pointBins == "11000") {
      strcat(secretCode, "Y");
    }
    else if (pointBins == "11001") {
      strcat(secretCode, "Z");
    }
    else if (pointBins == "11010") {
      strcat(secretCode, "2");
    }
    else if (pointBins == "11011") {
      strcat(secretCode, "3");
    }
    else if (pointBins == "11100") {
      strcat(secretCode, "4");
    }
    else if (pointBins == "11101") {
      strcat(secretCode, "5");
    }
    else if (pointBins == "11110") {
      strcat(secretCode, "6");
    }
    else if (pointBins == "11111") {
      strcat(secretCode, "7");
    }
  }
  Serial.println(" ");
  Serial.println("Your Secret Code is: ");
  midCode = secretCode;
  Serial.println(midCode.substring(1, 17));

  keypadDebug();
}

/*
 * This is the actual authentication part of the code.
 * 
 * The function below stores and checks the keys that the user enters against the stored passcode.
 * It also checks for any input from the NodeMCU chip.
 * 
 * If the correct passcode is entered and no signal for a password reset or remote lock is detected, it proceeds.
 */

void keypadDebug() {
  int i;

  Serial.println("Please enter your 10 digit PIN.");

  for (i = 0; i < 10; i++) {
    while ((keyEntered[i] = lockKeypad.getKey()) == NO_KEY) {
      delay(1);
      int remLock = changePassword();
      if (remLock == 1) {
        while (remLock != 0) {
          changePassword();
        }
      }
    }
    while (lockKeypad.getKey() != NO_KEY) {
      delay(1);
    }
    Serial.print('*');
  }
  Serial.println(" ");

  for (i = 0; i < 10; i++) {
    if (Passcode[i] != keyEntered[i]) {
      Serial.println("Passcode is incorrect.");
      Serial.println("Safe Locked, Please Retry.");
      keypadDebug();
    }
    else {
      if (i == 9) {
        Serial.println("Please enter 2 Factor Authentication Code");
        delay(1);
        getInput2FA();
      }
    }
  }
}

/*
 * This section of code calculates the actual TOTP code at the time that it is called, meaning that it wont update like the 2FA on the phone unless it is called again.
 * That can be changed so it refreshes its code but I haven't implemented that yet.
 * 
 * The function simply takes the user input and stores it and checks it against the system generated TOTP.
 * Like the other input requesting functions, it also checks for input in from the NodeMCU chip.
 */

void getInput2FA() {

  for (int i = 0; i < 6; i++) {
    while ((totpEntered[i] = lockKeypad.getKey()) == NO_KEY) {
      delay(1);
      int remLock = changePassword();
      if (remLock == 1) {
        while (remLock != 0) {
          changePassword();
        }
      }
    }
    while (lockKeypad.getKey() != NO_KEY) {
      delay(1);
    }
    Serial.print(totpEntered[i]);
  }
  Serial.println(" ");

  long GMT = rtc.getTimestamp();
  twoFACode = totp.getCode(GMT);

  for (int i = 0; i < 6; i++) {
    if (totpEntered[i] != twoFACode[i]) {
      Serial.print("Correct code according to GMT time is:");
      Serial.println(twoFACode);

      Serial.println("Safe Locked, Please Retry.");
      keypadDebug();
    }
    else {
      if (i == 5) {
        Serial.println("2FA Code accepted.");
        finStart();
      }
    }
  }
}

/*
 * This starts the fingerprint sensor and will initalize it on first boot. It will also send a calibration message to the sensor and wait for an input.
 * If none is received, it will display a connection error.
 * 
 * This also prevents the calibration message to be sent again after first boot as this would cause a communication error 2/3 times.
 */

void finStart() {
  do {
    delay(1);
  } while (!Serial);

  finSensor.begin(57600);

  if (hasBeenSetup == false) {
    if (finSensor.verifyPassword() == true) {
      Serial.println("Fingerprint Sensor Initialized...");
      int remLock = changePassword();
      if (remLock == 1) {
        while (remLock != 0) {
          changePassword();
        }
      }
    }
    else {
      Serial.println("Fingerprint Sensor not Detected.... Check Wiring?"); //CHANGE THIS TO TAMPER ALARM IN FUTURE
      for (int i = 1; i > 0; i++) {
        delay(1);
      }
    }
    finPreEnroll();
  }
  finEnroll();
}

/*
 * Only ever called when a fingerprint is being enrolled, at first boot.
 * Its sole purpose is to tell users waht to do for the fingerprint sensor.
 */

void finPreEnroll() {
  Serial.println("Please Wait...");
  delay(1300);
  Serial.println("Only one finger will be enrolled into the lock system");
  delay(1250);
  Serial.println("This is to prevent others from randomly adding fingerprints into the system.");
  delay(4250);
  Serial.println(" ");

  finEnroll();
}

/*
 * This function is used to enroll the actual fingerprint at first boot and to check it against the stored fingerprint for unlocking the safe.
 * The way the function works is that it takes an image of your fingerprint and converts it into a byte array.
 * It is then used to create a model with which your fingerprint can be predicted after first boot.
 * The model is then checked against the actual fingerprint before getting stored to the specified memory block.
 * 
 * When unlocking, the function takes an image of your fingerprint and runs it against all the stored fingerprint models to check if you are the owner of the lock.
 * 
 * It also contains the actual code that executes once the lock is open, such as sending an input to the NodeMCU chip to alert the user that the lock has been opened.
 */

void finEnroll() {
  int img = -1;

  for (int i = 1; i < 3; i++) {
    img = -1;

    if (i == 1) {
      Serial.println("Please gently press your finger against the fingerprint sensor...");
      delay(3750);
    } else {
      Serial.println("Please gently press your finger against the fingerprint sensor... again");
      delay(3750);
    }

    while (img != 1) {
      img = finSensor.getImage();
      if (img == FINGERPRINT_OK) {
        Serial.println("Fingerprint Registered...");
        Serial.println("Please keep your finger on the sensor...");
        delay(250);
        break;
      } else if (img == FINGERPRINT_NOFINGER) {
        Serial.println("Are you sure your finger is on the sensor? Please Try again.");
        delay(2500);
        finEnroll();
      } else if (img == FINGERPRINT_PACKETRECIEVEERR) {
        Serial.println("The sensor has lost connection to the control unit.");
        Serial.println("Rebooting...");
        delay(2000);
        finStart();
      } else if (img == FINGERPRINT_IMAGEFAIL) {
        Serial.println("The sensor was unable to capture a valid print.");
        delay(2500);
        finEnroll();
      } else {
        Serial.println("Something has gone horribly wrong...");
        for (int i = 1; i > 0; i++) {
          delay(1);
        }
      }
    }

    img = finSensor.image2Tz(i);
    if (img == FINGERPRINT_OK) {
      Serial.println("Print has been sucessfully converted into a byte array");
      delay(250);
    } else if (img == FINGERPRINT_IMAGEMESS) {
      Serial.println("The taken print was too messy to use. Let's try again...");
      delay(250);
      finEnroll();
    } else if (img == FINGERPRINT_PACKETRECIEVEERR) {
      Serial.println("The sensor has lost connection to the control unit.");
      Serial.println("Rebooting...");
      delay(1000);
      finStart();
    } else if (img == FINGERPRINT_FEATUREFAIL) {
      Serial.println("No distinguishable fingerprint features were detected...");
      Serial.println("Let's try again with another finger...");
      delay(500);
      finEnroll();
    } else if (img == FINGERPRINT_INVALIDIMAGE) {
      Serial.println("This isn't a valid image...");
      Serial.println("Let's try again with another finger...");
      delay(500);
      finEnroll();
    } else {
      Serial.println("Oh Noes! Something isn't working!!");
      for (int i = 1; i > 0; i++) {
        delay(1);
      }
    }

    if (i == 1) {
      if (hasBeenSetup == false) {
        Serial.println("Please remove your finger from the sensor...");
        delay(3500);
        img = 0;
        while (img != FINGERPRINT_NOFINGER) {
          img = finSensor.getImage();
        }
      } else {
        img = finSensor.fingerFastSearch();
        if (img == FINGERPRINT_OK) {
          Serial.print("Fingerprint matched! Welcome!");

          digitalWrite(Act, HIGH);
          Serial2.print("open now..");
          Serial.println("Safe is open. Press any key to close and lock.");

          char isOpen;
          while ((isOpen = lockKeypad.getKey()) == NO_KEY) {
            delay(1);
          }
          digitalWrite(Act, LOW);
          Serial.println("Safe Closed");
          Serial2.print("closed");
          keypadDebug();
        } else if (img == FINGERPRINT_PACKETRECIEVEERR) {
          Serial.println("The sensor has lost connection to the control unit.");
          Serial.println("Rebooting...");
          delay(1000);
          finEnroll();
        } else if (img == FINGERPRINT_NOTFOUND) {
          Serial.println("This Fingerprint is not valid");
          Serial.println("Please Try again...");
          delay(2000);
          keypadDebug();
        }
      }
    }
  }

  Serial.println("Proceeding to fingerprint model creation...");
  Serial.println("Please keep your finger on the sensor and please keep still");
  delay(3500);

  img = finSensor.createModel();
  if (img == FINGERPRINT_OK) {
    Serial.println("Fingerprint matches with prints & model. Model creation complete...");
    Serial.println("Please continue to keep your finger on the sensor and still");
    delay(250);
  } else if (img == FINGERPRINT_PACKETRECIEVEERR) {
    Serial.println("The sensor has lost connection to the control unit.");
    Serial.println("Rebooting...");
    delay(1000);
    finStart();
  } else if (img == FINGERPRINT_ENROLLMISMATCH) {
    Serial.println("Fingerprint DOES NOT match with recorded prints and model.");
    Serial.println("Let's try again with another finger...");
    delay(500);
    finEnroll();
  } else {
    Serial.println("Something happenning that isn't supposed to happen...");
    for (int i = 1; i > 0; i++) {
      delay(1);
    }
  }

  Serial.println("Proceeding to store fingerprint model...");
  img = finSensor.storeModel(finID);
  if (img == FINGERPRINT_OK) {
    Serial.println("Print & model stored! You may now remove your finger.");
    delay(2500);
    hasBeenSetup = true;
    Serial.println("Rebooting...");
    delay(1000);
    keypadDebug();
  } else if (img == FINGERPRINT_PACKETRECIEVEERR) {
    Serial.println("The sensor has lost connection to the control unit.");
    Serial.println("Rebooting...");
    delay(1000);
    finStart();
  } else if (img == FINGERPRINT_BADLOCATION) {
    Serial.println("The sensor has tried to store the fingerprint in occupied memory");
    Serial.println("The print enrollment process will now restart...");
    delay(500);
    finEnroll();
  } else if (img == FINGERPRINT_FLASHERR) {
    Serial.println("The sensor has tried to write to unaccessible memory.");
    Serial.println("The print enrollment process will now restart...");
    delay(500);
    finEnroll();
  } else {
    Serial.println("Mr. Stark, I don't feel so good.");
    for (int i = 1; i > 0; i++) {
      delay(1);
    }
  }
}

/*
 * This function actually does much more than just changing the password and actually also checks if the remote lock is called.
 * 
 * If a password is changed, it will also send feedback to the NodeMCU chip as confirmation.
 * In the case of a remote lock, it will either return a 1 or a 0 to the function that calls it.
 * If the remote lock is activated, it will freeze the safe and take no input until the remote lock is deactivaterd and a 0 is returned.
 */

int changePassword() {
  if (Serial2.available()) {
    delay(100);
    Serial2.readBytesUntil('`', recStr, 10);
    Serial.println("Detected input");
    Serial.println(recStr);
    if (recStr[0] == '1') {
      Serial.println("Received data: ");
      Serial.println(recStr);
      for (int i = 0; i < 10; i++) {
        Passcode[i] = recStr[i];
      }
      hasBeenChanged = true;
      Serial.println("New Passcode: ");
      Serial.println(Passcode);
      char recStr[10] = "";
      Serial.println("Received from Node; now sending - positive");
      Serial2.print("positive");
      takePass();
    } else if (recStr[0] == 't') {
      delay(2500);
      Serial.println("Safe is remotely locked");
      Serial2.flush();
      return 1;
    } else if (recStr[0] == 'f') {
      delay(2500);
      Serial.println("Safe is remotely unlocked");
      Serial2.flush();
      takePass();
      return 0;
    }
    
  }
}

/*
 * In the case of my project, void loop is not needed.
 */
 
void loop() {
  // put your main code here, to run repeatedly:

}
